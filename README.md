# Dynamic PDDL planning with Jupyter:

This is an attempt to bypass expressiveness limitations imposed in the traditional PDDL representation version. The current version of the tool aims to simulate emergent situations and dynamics at random instances during the execution of the initially calculated plan. This way stochasticity and unexpected events could be handled by a dynamically assigned PDDL parser data object, which complies with the closed world assumption by its design. These become feasible in the expense of generality and replicability since the specific twicking events are problem and domain specific.

The current framework implements user/code specified events at random plan execution steps, which consequently lead to reseting the parser object appropriately and regenerate the solution plan based on the newly observed situation. Two uninformed (blind) search algorithms have been implemented for demonstration purposes only: Breadth First Search and Depth First Search. However, the intention is to continue populating the list of implemented search algorithms furthermore, enabling thorougher benchmarking tests and comparative analysis.

More specifically, the PDDL parser provides access to Python set objects as its internal variables which constitute the definition of the specific planning problem (set of actions, set of initial facts, set of goal facts, set of objects, etc.). The inputs to the PDDL parser are handled through the Jupyter Notebook, comprising the usual two representations of the domain and problem in PDDL syntax.

Specifically, in an attempt to model more realistic aspects of relevant real-life missions, this framework focuses on a fully observable object stacking environment deploying autonomous vehicles in a 2D grid map which can immitate a large variety of swarming problems. The problem is fully observable by a centralised programming BDI rationale agent. However, each situation is evaluated based on the assumption of a limited visibility for all operating autonomous vehicles. Currently any additional vehicle that may participate in the mission at execution time presents homogeneous attributes with every other. Finally, a function calculating each location coverage levels by the synergetic vehicles has become available also for heuristic search and reinforcement learning applications. 

In practise the PDDL parser became available by minorly adapting the functionality developed by the user: meneguzzi in the following URL: https://github.com/pucrs-automated-planning/pddl-parser.

This work has been part of my Master-of-Science thesis on Artificial Intelligence, in the Computer Science Department of the Aristotle University of Thessaloniki, Greece.

# Source (to be translated in English):
Ο κώδικας υλοποιήθηκε με βασικό μεταφραστή την έκδοση της Python 3.8 για Windows καθώς κατά την περίοδο ανάπτυξής του η έκδοση 3.8.2 ήταν η πιο πρόσφατη σταθερή (stable) έκδοση της Python. Το περιβάλλον υλοποίησης ήταν το Jupyter IDE για Windows. Ο κώδικας στο Jupyter Notebook αποτελείται από 43 αυτόνομα κελιά τα οποία εκτείνονται σε οριακά πάνω από 1000 γραμμές συνολικά. Τα 43 αυτά κελιά μπορούν να ομαδοποιηθούν σε τρεις μεγάλες κατηγορίες:
+ Κελιά 1-14: είναι ο κώδικας γενικού σκοπού και οι συναρτήσεις διαχείρισης των κατάλληλων δομών του parser αλλά και οι συμβατές υλοποιήσεις των βασικών συναρτήσεων αναζήτησης.
+ Κελιά 15-40: είναι ο κώδικας ειδικού σκοπού που περιλαμβάνει συναρτήσεις σχετικές με την αναπαράσταση του συγκεκριμένου πεδίου προβλημάτων προγραμματισμού (δλδ. συλλογή και στοίβαξη αντικειμένων από αυτόνομα οχήματα) αλλά και με την προσομοίωση απρόσμενων συμβάντων που επηρεάζουν την κατάσταση του υβριδικού πράκτορα προγραμματισμού κατά την διάρκεια της διαδικασίας αναζήτησης (αριθμός οχημάτων, αριθμός αντικειμένων, περιοχές μετακίνησης και γνωστός χάρτης, κτλ.).
+ Κελιά 41-42-43: είναι ο κεντρικός κώδικας (script) που καλεί με την κατάλληλη σειρά τις παραπάνω συναρτήσεις για τον αρχικό ορισμό του προβλήματος, την επίλυσή του, την εκτέλεση του αρχικού πλάνου και τον επαναληπτικό προγραμματισμό του (επαναπροσαρμογή του αρχικού πλάνου) με βάση τα τυχαία συμβάντα που εμφανίζονται σε προκαθορισμένες στιγμές και επηρεάζουν το πρόβλημα και την λύση του.

Στο συγκεκριμένο σημείο θα εστιάσουμε στην τελευταία κατηγορία κελιών 41-42-43 του κώδικα και στην περιγραφή της λειτουργικής ροής του βασικού/κεντρικού κώδικα. Πιο συγκεκριμένα στο:
+ Κελί 41: Ορίζεται ένα αντικείμενο της εξωτερικής κλάσης PDDL_Parser στο οποίο δίνεται η αναπαράσταση PDDL του πεδίου και του προβλήματος για να τα αναλύσει συντακτικά και να ανατεθούν οι σωστές τιμές στις εσωτερικές του μεταβλητές (στόχοι, αρχική κατάσταση, αντικείμενα, οχήματα, ενέργειες, περιοχές μετακίνησης, στοίβες κτλ.). Τέλος στο ίδιο κελί καλείται η συνάρτηση γενικού σκοπού ‘generate_plan’ για να επιλύσει το πρόβλημα που ορίστηκε με βάση τον default αλγόριθμο αναζήτησης Breadth First Search (βλ. κελί 9 στο Jupyter Notebook) ο οποίος είναι πλήρης και βρίσκει πάντοτε την συντομότερη λύση εφόσον αυτή υφίσταται.
+ Κελί 42: Εδώ ορίζεται η συνάρτηση ‘progress_system_state’ η οποία είναι υπεύθυνη να υλοποιήσει το πιο πρόσφατο έγκυρο/ενεργό πλάνο προγραμματισμού με βάση την πιο πρόσφατη κατάσταση που παρατηρήθηκε. Η συνάρτηση αυτή λαμβάνει ως όρισμα το ‘apply_plan_steps_to_replan’ το οποίο αναπαριστά τον αριθμό των βημάτων/μεταβάσεων του έγκυρου/ενεργού πλάνου που θα υλοποιηθούν μέχρι να επανακαθοριστεί το πλάνο εκ νέου. Στην συνάρτηση αυτή έχει προβλεφθεί επίσης η τυχαία εκτέλεση τυχαίων (εφαρμόσιμων κάθε φορά) ενεργειών αντί για την αλληλουχία του πλάνου ώστε να δοθεί η δυνατότητα προσομοίωσης αντίστοιχων συχνών σφαλμάτων στην συμπεριφορά των αυτόνομων οχημάτων (βλ. γραμμή 14 κελί 42).
+ Κελί 43: Τέλος στο κελί αυτό υλοποιείται το κεντρικό script το οποίο εισάγει τις απρόσμενες μεταβολές στο πρόβλημα του συστήματος (βλ. γραμμή 23 κελί 43), υλοποιεί τον βρόχο επαναπρογραμματισμού (είτε επειδή παρήλθαν αρκετά βήματα - βλ. κελί 42, είτε γιατί εισήχθει μια τυχαία μεταβολή στο πρόβλημα - βλ. γραμμή 23 κελί 43) στην γραμμή 66 κελί 43. Επίσης υπολογίζεται η τιμή μιας συνάρτησης χρησιμότητας (βλ. κελί 37) ‘find_locations_scores’ η οποία αναπαριστά τον βαθμό που παρακολουθείται κάθε γνωστή περιοχή/τοποθεσία του χάρτη (μέχρι εκείνη την δεδομένη στιγμή) από το σύνολο των αυτόνομων οχημάτων που επιχειρούν εκείνη την στιγμή με συγκεκριμένο περιορισμό ορατότητας ‘visibility=1’.

Η παραπάνω λειτουργική ροή μπορεί να συνοψιστεί και στην παρακάτω εικόνα η οποία αναπαριστά την αρχιτεκτονική του εργαλείου που υλοποιήθηκε και τις βασικές λειτουργίες του.
